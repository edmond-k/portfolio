self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/constants/constants.js":
/*!************************************!*\
  !*** ./src/constants/constants.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "projects": function() { return /* binding */ projects; },
/* harmony export */   "TimeLineData": function() { return /* binding */ TimeLineData; }
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
var projects = [{
  title: 'NFT Marketplace',
  description: "This is a prototype cross-chain NFT marketplace made with React, Moralis framework, Javascript, Ant Design and Node.js. The marketplace features include listing NFTs in your wallet for sale, buying listed NFTs and a summary of your transactions. ",
  image: '/images/marketplace.jpg',
  tags: ['React', 'Moralis', 'Javascript', 'Node.js'],
  source: 'https://google.com',
  visit: 'https://google.com',
  id: 0
}, {
  title: 'Staking DAPP',
  description: "This is a staking DAPP that allows users to stake and unstake three types of ERC20 tokens, a DAPP Token, WETH and DAI. The DAPP token is the main token which users get rewarded with once they stake either WETH or DAI token. After receiveing their rewards users can stake their DAPP token for more rewards. ",
  image: '/images/staking DAPP.jpg',
  tags: ['React', 'Usedapp', 'Node.js', 'Typecript', 'Material UI'],
  source: 'https://google.com',
  visit: 'https://google.com',
  id: 1
}, {
  title: 'Minting DAPP',
  description: "This is an NFT minting DAPP that facilitates the minting of erc721a non-fungible tokens. The DAPP checks whether the users has enough ETH required to mint the number of tokens choosen. If not the transaction is not broadcasted to the smart contract and an alert of insufficient ETH is issued. If the users has enough eth, a function call is broadcasted to the deployed smart contract via Infura. The call contains the mint amount and value(mint price). Once the minting transaction is complete an alert is issued informing the user of the succesful mint. ",
  image: '/images/minting DAPP.jpg',
  tags: ['React', 'Usedapp', 'Material UI', 'Typescript'],
  source: 'https://google.com',
  visit: 'https://google.com',
  id: 2
}, {
  title: 'Whitelist Collection',
  description: "A simple whitelist collection DAPP for an NFT project. The app allows users to submit their addresses tio be whitelisted for minting. But before their address is collected, the app checks whether their wallets contain the a minimum amount. Addresses collected are stored on firebase.",
  image: '/images/whitelist collection website.jpg',
  tags: ['React', 'Typecript', 'Firebase', 'Usedapp', 'Material UI'],
  source: 'https://google.com',
  visit: 'https://google.com',
  id: 3
}, {
  title: 'Minting DAPP',
  description: "This is a minting DAPP for minting NFTs. The app allows users to connect an ethereum wallet either with Metamask or WalletConnect. Once a wallet is connected the user can mint a ",
  image: '/images/minting DAPP OG.jpg',
  tags: ['React', 'Usedapp', 'Material UI', 'Typescript'],
  source: 'https://google.com',
  visit: 'https://google.com',
  id: 2
}];
var TimeLineData = [{
  year: 2017,
  text: 'Started my journey through a web development bootcamp'
}, {
  year: 2018,
  text: 'Worked as a freelance Technical writer and content creator'
}, {
  year: 2019,
  text: 'Worked as a freelance web developer'
}, {
  year: 2020,
  text: 'Started working as a blockchain developer'
}, {
  year: 2021,
  text: 'Still working as freelance developer'
}];

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnN0YW50cy9jb25zdGFudHMuanMiXSwibmFtZXMiOlsicHJvamVjdHMiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiaW1hZ2UiLCJ0YWdzIiwic291cmNlIiwidmlzaXQiLCJpZCIsIlRpbWVMaW5lRGF0YSIsInllYXIiLCJ0ZXh0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBTyxJQUFNQSxRQUFRLEdBQUcsQ0FDdEI7QUFDRUMsT0FBSyxFQUFFLGlCQURUO0FBRUVDLGFBQVcsRUFBRSx3UEFGZjtBQUdJQyxPQUFLLEVBQUUseUJBSFg7QUFJSUMsTUFBSSxFQUFFLENBQUMsT0FBRCxFQUFVLFNBQVYsRUFBcUIsWUFBckIsRUFBbUMsU0FBbkMsQ0FKVjtBQUtFQyxRQUFNLEVBQUUsb0JBTFY7QUFNRUMsT0FBSyxFQUFFLG9CQU5UO0FBT0VDLElBQUUsRUFBRTtBQVBOLENBRHNCLEVBVXRCO0FBQ0VOLE9BQUssRUFBRSxjQURUO0FBRUVDLGFBQVcsRUFBQyxvVEFGZDtBQUdFQyxPQUFLLEVBQUUsMEJBSFQ7QUFJRUMsTUFBSSxFQUFFLENBQUMsT0FBRCxFQUFVLFNBQVYsRUFBcUIsU0FBckIsRUFBZ0MsV0FBaEMsRUFBNkMsYUFBN0MsQ0FKUjtBQUtFQyxRQUFNLEVBQUUsb0JBTFY7QUFNRUMsT0FBSyxFQUFFLG9CQU5UO0FBT0VDLElBQUUsRUFBRTtBQVBOLENBVnNCLEVBbUJ0QjtBQUNFTixPQUFLLEVBQUUsY0FEVDtBQUVFQyxhQUFXLEVBQUUsNmlCQUZmO0FBR0lDLE9BQUssRUFBRSwwQkFIWDtBQUlJQyxNQUFJLEVBQUUsQ0FBQyxPQUFELEVBQVUsU0FBVixFQUFxQixhQUFyQixFQUFvQyxZQUFwQyxDQUpWO0FBS0VDLFFBQU0sRUFBRSxvQkFMVjtBQU1FQyxPQUFLLEVBQUUsb0JBTlQ7QUFPRUMsSUFBRSxFQUFFO0FBUE4sQ0FuQnNCLEVBNEJ0QjtBQUNFTixPQUFLLEVBQUUsc0JBRFQ7QUFFRUMsYUFBVyxFQUFFLDZSQUZmO0FBR0VDLE9BQUssRUFBRSwwQ0FIVDtBQUlFQyxNQUFJLEVBQUUsQ0FBQyxPQUFELEVBQVUsV0FBVixFQUF1QixVQUF2QixFQUFtQyxTQUFuQyxFQUE4QyxhQUE5QyxDQUpSO0FBS0VDLFFBQU0sRUFBRSxvQkFMVjtBQU1FQyxPQUFLLEVBQUUsb0JBTlQ7QUFPRUMsSUFBRSxFQUFFO0FBUE4sQ0E1QnNCLEVBcUN0QjtBQUNFTixPQUFLLEVBQUUsY0FEVDtBQUVFQyxhQUFXLEVBQUUsb0xBRmY7QUFHSUMsT0FBSyxFQUFFLDZCQUhYO0FBSUlDLE1BQUksRUFBRSxDQUFDLE9BQUQsRUFBVSxTQUFWLEVBQXFCLGFBQXJCLEVBQW9DLFlBQXBDLENBSlY7QUFLRUMsUUFBTSxFQUFFLG9CQUxWO0FBTUVDLE9BQUssRUFBRSxvQkFOVDtBQU9FQyxJQUFFLEVBQUU7QUFQTixDQXJDc0IsQ0FBakI7QUFnREEsSUFBTUMsWUFBWSxHQUFHLENBQzFCO0FBQUVDLE1BQUksRUFBRSxJQUFSO0FBQWNDLE1BQUksRUFBRTtBQUFwQixDQUQwQixFQUUxQjtBQUFFRCxNQUFJLEVBQUUsSUFBUjtBQUFjQyxNQUFJLEVBQUU7QUFBcEIsQ0FGMEIsRUFHMUI7QUFBRUQsTUFBSSxFQUFFLElBQVI7QUFBY0MsTUFBSSxFQUFFO0FBQXBCLENBSDBCLEVBSTFCO0FBQUVELE1BQUksRUFBRSxJQUFSO0FBQWNDLE1BQUksRUFBRTtBQUFwQixDQUowQixFQUsxQjtBQUFFRCxNQUFJLEVBQUUsSUFBUjtBQUFjQyxNQUFJLEVBQUU7QUFBcEIsQ0FMMEIsQ0FBckIiLCJmaWxlIjoic3RhdGljL3dlYnBhY2svcGFnZXMvaW5kZXguMmRhZjRkZDYyMTNmYjgwOGI3MTkuaG90LXVwZGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBwcm9qZWN0cyA9IFtcbiAge1xuICAgIHRpdGxlOiAnTkZUIE1hcmtldHBsYWNlJyxcbiAgICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgcHJvdG90eXBlIGNyb3NzLWNoYWluIE5GVCBtYXJrZXRwbGFjZSBtYWRlIHdpdGggUmVhY3QsIE1vcmFsaXMgZnJhbWV3b3JrLCBKYXZhc2NyaXB0LCBBbnQgRGVzaWduIGFuZCBOb2RlLmpzLiBUaGUgbWFya2V0cGxhY2UgZmVhdHVyZXMgaW5jbHVkZSBsaXN0aW5nIE5GVHMgaW4geW91ciB3YWxsZXQgZm9yIHNhbGUsIGJ1eWluZyBsaXN0ZWQgTkZUcyBhbmQgYSBzdW1tYXJ5IG9mIHlvdXIgdHJhbnNhY3Rpb25zLiBcIixcbiAgICAgIGltYWdlOiAnL2ltYWdlcy9tYXJrZXRwbGFjZS5qcGcnLFxuICAgICAgdGFnczogWydSZWFjdCcsICdNb3JhbGlzJywgJ0phdmFzY3JpcHQnLCAnTm9kZS5qcyddLFxuICAgIHNvdXJjZTogJ2h0dHBzOi8vZ29vZ2xlLmNvbScsXG4gICAgdmlzaXQ6ICdodHRwczovL2dvb2dsZS5jb20nLFxuICAgIGlkOiAwLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdTdGFraW5nIERBUFAnLFxuICAgIGRlc2NyaXB0aW9uOlwiVGhpcyBpcyBhIHN0YWtpbmcgREFQUCB0aGF0IGFsbG93cyB1c2VycyB0byBzdGFrZSBhbmQgdW5zdGFrZSB0aHJlZSB0eXBlcyBvZiBFUkMyMCB0b2tlbnMsIGEgREFQUCBUb2tlbiwgV0VUSCBhbmQgREFJLiBUaGUgREFQUCB0b2tlbiBpcyB0aGUgbWFpbiB0b2tlbiB3aGljaCB1c2VycyBnZXQgcmV3YXJkZWQgd2l0aCBvbmNlIHRoZXkgc3Rha2UgZWl0aGVyIFdFVEggb3IgREFJIHRva2VuLiBBZnRlciByZWNlaXZlaW5nIHRoZWlyIHJld2FyZHMgdXNlcnMgY2FuIHN0YWtlIHRoZWlyIERBUFAgdG9rZW4gZm9yIG1vcmUgcmV3YXJkcy4gXCIsXG4gICAgaW1hZ2U6ICcvaW1hZ2VzL3N0YWtpbmcgREFQUC5qcGcnLFxuICAgIHRhZ3M6IFsnUmVhY3QnLCAnVXNlZGFwcCcsICdOb2RlLmpzJywgJ1R5cGVjcmlwdCcsICdNYXRlcmlhbCBVSSddLFxuICAgIHNvdXJjZTogJ2h0dHBzOi8vZ29vZ2xlLmNvbScsXG4gICAgdmlzaXQ6ICdodHRwczovL2dvb2dsZS5jb20nLFxuICAgIGlkOiAxLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdNaW50aW5nIERBUFAnLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgaXMgYW4gTkZUIG1pbnRpbmcgREFQUCB0aGF0IGZhY2lsaXRhdGVzIHRoZSBtaW50aW5nIG9mIGVyYzcyMWEgbm9uLWZ1bmdpYmxlIHRva2Vucy4gVGhlIERBUFAgY2hlY2tzIHdoZXRoZXIgdGhlIHVzZXJzIGhhcyBlbm91Z2ggRVRIIHJlcXVpcmVkIHRvIG1pbnQgdGhlIG51bWJlciBvZiB0b2tlbnMgY2hvb3Nlbi4gSWYgbm90IHRoZSB0cmFuc2FjdGlvbiBpcyBub3QgYnJvYWRjYXN0ZWQgdG8gdGhlIHNtYXJ0IGNvbnRyYWN0IGFuZCBhbiBhbGVydCBvZiBpbnN1ZmZpY2llbnQgRVRIIGlzIGlzc3VlZC4gSWYgdGhlIHVzZXJzIGhhcyBlbm91Z2ggZXRoLCBhIGZ1bmN0aW9uIGNhbGwgaXMgYnJvYWRjYXN0ZWQgdG8gdGhlIGRlcGxveWVkIHNtYXJ0IGNvbnRyYWN0IHZpYSBJbmZ1cmEuIFRoZSBjYWxsIGNvbnRhaW5zIHRoZSBtaW50IGFtb3VudCBhbmQgdmFsdWUobWludCBwcmljZSkuIE9uY2UgdGhlIG1pbnRpbmcgdHJhbnNhY3Rpb24gaXMgY29tcGxldGUgYW4gYWxlcnQgaXMgaXNzdWVkIGluZm9ybWluZyB0aGUgdXNlciBvZiB0aGUgc3VjY2VzZnVsIG1pbnQuIFwiLFxuICAgICAgaW1hZ2U6ICcvaW1hZ2VzL21pbnRpbmcgREFQUC5qcGcnLFxuICAgICAgdGFnczogWydSZWFjdCcsICdVc2VkYXBwJywgJ01hdGVyaWFsIFVJJywgJ1R5cGVzY3JpcHQnXSxcbiAgICBzb3VyY2U6ICdodHRwczovL2dvb2dsZS5jb20nLFxuICAgIHZpc2l0OiAnaHR0cHM6Ly9nb29nbGUuY29tJyxcbiAgICBpZDogMixcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnV2hpdGVsaXN0IENvbGxlY3Rpb24nLFxuICAgIGRlc2NyaXB0aW9uOiBcIkEgc2ltcGxlIHdoaXRlbGlzdCBjb2xsZWN0aW9uIERBUFAgZm9yIGFuIE5GVCBwcm9qZWN0LiBUaGUgYXBwIGFsbG93cyB1c2VycyB0byBzdWJtaXQgdGhlaXIgYWRkcmVzc2VzIHRpbyBiZSB3aGl0ZWxpc3RlZCBmb3IgbWludGluZy4gQnV0IGJlZm9yZSB0aGVpciBhZGRyZXNzIGlzIGNvbGxlY3RlZCwgdGhlIGFwcCBjaGVja3Mgd2hldGhlciB0aGVpciB3YWxsZXRzIGNvbnRhaW4gdGhlIGEgbWluaW11bSBhbW91bnQuIEFkZHJlc3NlcyBjb2xsZWN0ZWQgYXJlIHN0b3JlZCBvbiBmaXJlYmFzZS5cIixcbiAgICBpbWFnZTogJy9pbWFnZXMvd2hpdGVsaXN0IGNvbGxlY3Rpb24gd2Vic2l0ZS5qcGcnLFxuICAgIHRhZ3M6IFsnUmVhY3QnLCAnVHlwZWNyaXB0JywgJ0ZpcmViYXNlJywgJ1VzZWRhcHAnLCAnTWF0ZXJpYWwgVUknXSxcbiAgICBzb3VyY2U6ICdodHRwczovL2dvb2dsZS5jb20nLFxuICAgIHZpc2l0OiAnaHR0cHM6Ly9nb29nbGUuY29tJyxcbiAgICBpZDogMyxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTWludGluZyBEQVBQJyxcbiAgICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgbWludGluZyBEQVBQIGZvciBtaW50aW5nIE5GVHMuIFRoZSBhcHAgYWxsb3dzIHVzZXJzIHRvIGNvbm5lY3QgYW4gZXRoZXJldW0gd2FsbGV0IGVpdGhlciB3aXRoIE1ldGFtYXNrIG9yIFdhbGxldENvbm5lY3QuIE9uY2UgYSB3YWxsZXQgaXMgY29ubmVjdGVkIHRoZSB1c2VyIGNhbiBtaW50IGEgXCIsXG4gICAgICBpbWFnZTogJy9pbWFnZXMvbWludGluZyBEQVBQIE9HLmpwZycsXG4gICAgICB0YWdzOiBbJ1JlYWN0JywgJ1VzZWRhcHAnLCAnTWF0ZXJpYWwgVUknLCAnVHlwZXNjcmlwdCddLFxuICAgIHNvdXJjZTogJ2h0dHBzOi8vZ29vZ2xlLmNvbScsXG4gICAgdmlzaXQ6ICdodHRwczovL2dvb2dsZS5jb20nLFxuICAgIGlkOiAyLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IFRpbWVMaW5lRGF0YSA9IFtcbiAgeyB5ZWFyOiAyMDE3LCB0ZXh0OiAnU3RhcnRlZCBteSBqb3VybmV5IHRocm91Z2ggYSB3ZWIgZGV2ZWxvcG1lbnQgYm9vdGNhbXAnLCB9LFxuICB7IHllYXI6IDIwMTgsIHRleHQ6ICdXb3JrZWQgYXMgYSBmcmVlbGFuY2UgVGVjaG5pY2FsIHdyaXRlciBhbmQgY29udGVudCBjcmVhdG9yJywgfSxcbiAgeyB5ZWFyOiAyMDE5LCB0ZXh0OiAnV29ya2VkIGFzIGEgZnJlZWxhbmNlIHdlYiBkZXZlbG9wZXInLCB9LFxuICB7IHllYXI6IDIwMjAsIHRleHQ6ICdTdGFydGVkIHdvcmtpbmcgYXMgYSBibG9ja2NoYWluIGRldmVsb3BlcicsIH0sXG4gIHsgeWVhcjogMjAyMSwgdGV4dDogJ1N0aWxsIHdvcmtpbmcgYXMgZnJlZWxhbmNlIGRldmVsb3BlcicsIH0sXG5dOyJdLCJzb3VyY2VSb290IjoiIn0=